import groovy.json.JsonOutput

import java.text.SimpleDateFormat

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'antlr'

sourceCompatibility = 1.8
version = "0.3"

/*
task wrapper(type: Wrapper) {
    gradleVersion = '4.1'
}
*/

repositories {
    mavenCentral()
}

buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath "com.github.jengelman.gradle.plugins:shadow:2.0.0"
    }
}


apply from: 'dependencies.gradle'
dependencies {
    antlr 'org.antlr:antlr4:4.5.3'

    compile libs.gsCollections
    compile libs.commonsLang
    compile libs.commonsIO
    compile libs.guava
    compile libs.slf4j

    testCompile 'junit:junit:4.12'
    testCompile 'org.assertj:assertj-core:3.8.0'
    testCompile 'nl.jqno.equalsverifier:equalsverifier:2.3.2'
}

// Adapted from https://github.com/rossng/gradle-antlr-intellij/blob/master/build.gradle

generateGrammarSource {
    def targetDir = file("${project.buildDir}/generated-src/main/java/")
    outputDirectory = targetDir
    arguments += ["-visitor", "-package", "tdanford.ideals.antlr"]

    doLast {
// copy the java generated by ANTLR into a folder outside the build directory for IntelliJ
        copy {
            from targetDir
            into "${projectDir}/src/generated/java"
        }
    }
}

// make sure that ANTLR generates java before compiling the project
// include the generated java code in the compilation
compileJava.dependsOn generateGrammarSource
compileJava {
    source += ["${project.buildDir}/generated-src/main/java"]
}

// when cleaning, remove the generated sources too
task removeGeneratedSource(type: Delete) {
    delete "${projectDir}/src/generated/"
}
clean.dependsOn removeGeneratedSource

// mark the generated source as such for IntelliJ IDEA
def ideaAntlrDir = file("${projectDir}/src/generated/java")
sourceSets.main.java.srcDirs += ideaAntlrDir
idea {
    module {
        generatedSourceDirs += ideaAntlrDir
    }
}

getGitProperties()
configureShadowJarTask(project, 'ideals', version, 'tdanford.ideals.visualization.PolynomialView')

def configureShadowJarTask(
        Project targetProject,
        String implTitle,
        String implVersion,
        String mainClassName
) {
    targetProject.apply plugin: "com.github.johnrengelman.plugin-shadow"

    targetProject.jar {
        manifest {
            attributes "Implementation-Title": implTitle
            attributes "Implementation-Version": implVersion
            attributes "Main-Class": mainClassName
        }
        // Easiest way to make sure people don't use the output of the normal 'jar' task
        archiveName = 'BROKEN-IGNORE'
    }

    File versionDir = file("${targetProject.buildDir}/git")
    File versionFile = file("${versionDir}/version.json")

    // Configure a task to write out a file containing information about the current version,
    // as retrieved from git. This file is pulled into the shadow JAR so that the version
    // info will be available in the app.
    targetProject.task('writeVersionInformation') {
        inputs.property('gitCommitId', gitProperties.'git.commit.id')
        inputs.property('version', version)
        outputs.file(versionFile)

        doLast {
            println targetProject.configurations.getByName("runtime").artifacts
            versionDir.mkdirs()
            def json = JsonOutput.toJson([
                    version: "${version}",
                    gitDescribe: "${gitProperties.'git.tags'}",
                    gitCommitId: "${gitProperties.'git.commit.id'}",
                    gitCommitShort: "${gitProperties.'git.commit.short'}",
                    gitCommitTime: "${gitProperties.'git.commit.time'}",
                    buildTime: "${gitProperties.'git.build.time'}"
            ]);
            versionFile.write(JsonOutput.prettyPrint(json));
        }
    }

    targetProject.shadowJar {
        dependsOn targetProject.writeVersionInformation
        from versionFile
        mergeServiceFiles()
    }

    targetProject.assemble.dependsOn targetProject.shadowJar
}

Map getGitProperties() {
    def outDateFmt = new SimpleDateFormat('yyyy-MM-dd hh:mm:ss a z')
    def inDateFmt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss X")
    def gitCmd = new File("${rootProject.projectDir}", ".git").exists() ?
            "git --git-dir ${rootProject.projectDir}/.git --work-tree ${rootProject.projectDir}" : "git"

    Map gitProps = [
            'git.branch':               "${gitCmd} symbolic-ref --short HEAD",
            'git.build.user.email':     "${gitCmd} config --get user.email",
            'git.build.user.name':      "${gitCmd} config --get user.name",
            'git.commit.id':            "${gitCmd} log -1 --pretty=format:%H",
            'git.commit.id.abbrev':     "${gitCmd} log -1 --pretty=format:%h",
            'git.commit.short':         "${gitCmd} rev-parse --short HEAD",
            'git.commit.message.short': "${gitCmd} log -1 --pretty=format:%s",
            'git.commit.user.email':    "${gitCmd} log -1 --pretty=format:%ce",
            'git.commit.user.name':     "${gitCmd} log -1 --pretty=format:%cn",
            'git.dirtyFiles':           "${gitCmd} status --porcelain",
            'git.remote.origin.url':    "${gitCmd} ls-remote --get-url origin",
            'git.tags':                 "${gitCmd} describe --tags"
    ].collectEntries { e -> [(e.key) : e.value.execute().text.trim()] }

    String rawCommitTime = "${gitCmd} log -1 --pretty=format:%ci".execute().text.trim()
    try {
        gitProps.'git.commit.time' = outDateFmt.format(inDateFmt.parse(rawCommitTime))
    } catch (Exception e) {
        gitProps.'git.commit.time' = outDateFmt.format(new Date())
    }
    gitProps.'git.build.time' = outDateFmt.format(new Date())
    gitProps.'git.dirtyFiles' = gitProps.'git.dirtyFiles'.tokenize('\n').collect({ x -> x.tokenize(' ')})
    gitProps.'git.isClean' = gitProps.'git.dirtyFiles'.size() == 0

    return gitProps
}

